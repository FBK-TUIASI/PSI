C51 COMPILER V9.59.0.0   TESTCAN                                                           12/05/2024 17:51:04 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE TESTCAN
OBJECT MODULE PLACED IN .\BIG8051\Objects\TestCAN.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE TestCAN.c OPTIMIZE(8,SPEED) BROWSE INCDIR(.\BIG8051\Include) DEBUG OBJEC
                    -TEXTEND PRINT(.\BIG8051\Listings\TestCAN.lst) TABS(3) OBJECT(.\BIG8051\Objects\TestCAN.obj)

line level    source

   1          //------------------------------------------------------------------------------------
   2          // NetCAN.c - aplicatie pentru microsistemul BIG8051 - Mikroelektronika
   3          //------------------------------------------------------------------------------------
   4          
   5          // se modifica CAN_Init() in fisierul can.c astfel incat CAN0CN = 0x41 in loc de 0xC1
   6          // si BITREG = 0x7CF1 (BRP = 1 in loc de 0)
   7          
   8          #include <c8051F040.h>     // declaratii SFR
   9           
  10          #include <wdt.h>
  11          #include <osc.h>
  12          #include <port.h>
  13          #include <timer.h>
  14          #include <uart0.h>
  15          #include <lcd.h>
  16          #include <keyboard.h>
  17          #include <can.h>
  18          #include <stdio.h>
  19          
  20          #define MAIN_MENU    0
  21          #define DSC_MENU     1
  22          #define WDI_MENU     2  
  23          #define RDI_MENU     3
  24          #define CDI_MENU     4
  25          #define IOCI_MENU    5
  26          
  27          
  28          extern CAN_Msg CAN_MsgTX, CAN_MsgRX;   // structuri de transmisie  si receptie mesaje CAN
  29          
  30          //************************************************************************************
  31          // INIT
  32          //************************************************************************************
  33          
  34          void BIG8051_Init(void){
  35   1      
  36   1         WDT_Disable();                   // dezactiveaza WDT
  37   1         SYSCLK_Init();                   // initializeaza si selecteaza oscilatorul ales in osc.h
  38   1         PORT_Init ();                    // conecteaza perifericele la pini si stabileste tipul pinilor
  39   1         LCD_Init();                      // 2 linii, display ON, cursor OFF, pozitia initiala (0,0)
  40   1         KEYB_Init();                     // initializeaza driver tastatura matriciala
  41   1         Timer0_Init();                   // initializeaza Timer 0 - intreruperi la 1 ms
  42   1         UART0_Init(EIGHT_BIT, 9600);     // initializeaza UART0 - conectare terminal la UART-USB
  43   1         CAN_Init();                      // initializeaza controlerul CAN, 1 Mbit/sec
  44   1         EA = 1;                          // validare globala intreruperi
  45   1      }
  46          
  47          //************************************************************************************
  48          // Print menu
  49          //************************************************************************************
  50          
  51          void print_submenu(){
  52   1            UART0_Putstr("A. Subfunction 1:  0x01. \r\n");
  53   1            UART0_Putstr("B. Subfunction 2:  0x02. \r\n");
  54   1            UART0_Putstr("C. Subfunction 3:  0x03. \r\n");
C51 COMPILER V9.59.0.0   TESTCAN                                                           12/05/2024 17:51:04 PAGE 2   

  55   1            UART0_Putstr("D. Subfunction 4:  0x04. \r\n");
  56   1            UART0_Putstr("\r\n");
  57   1            UART0_Putstr("0. To main menu:   0x10. \r\n\r\n");
  58   1      }
  59          
  60          
  61          void print_menu(unsigned char menu){
  62   1         if(menu == MAIN_MENU){     
  63   2            UART0_Putstr("\r\n");
  64   2            UART0_Putstr("Please select option from menu:\r\n");
  65   2            UART0_Putstr("1. Diagnostic Session Control:    0x10. \r\n");
  66   2            UART0_Putstr("2. Write Data by Identifier:      0x2E. \r\n");
  67   2            UART0_Putstr("3. Read Data by Identifier:       0x22. \r\n");
  68   2            UART0_Putstr("4. Clear Diagnostic Information:  0x14. \r\n");
  69   2            UART0_Putstr("5. I/O Control by Identifier:     0x2F. \r\n");
  70   2            UART0_Putstr("\r\n\r\n");
  71   2         }
  72   1         else if(menu == DSC_MENU){
  73   2            UART0_Putstr("\t- 1. Diagnostic Session Control:   0x10. \r\n");
  74   2            print_submenu();
  75   2         }  
  76   1         else if(menu == WDI_MENU){
  77   2            UART0_Putstr("\t- 2. Write Data by Identifier:     0x2E. \r\n");
  78   2            print_submenu();
  79   2         }  
  80   1         else if(menu == RDI_MENU){
  81   2            UART0_Putstr("\t- 3. Read Data by Identifier:         0x22. \r\n");
  82   2            print_submenu();
  83   2         }  
  84   1         else if(menu == CDI_MENU){
  85   2            UART0_Putstr("\t- 4. Clear Diagnostic Information: 0x14. \r\n");
  86   2            print_submenu();
  87   2         }
  88   1         else if(menu == IOCI_MENU){
  89   2            UART0_Putstr("\t- 5. I/O Control by Identifier:    0x2F. \r\n");
  90   2            print_submenu();
  91   2         }
  92   1      }
  93          
  94          
  95          //************************************************************************************
  96          // Do something
  97          //************************************************************************************
  98          
  99          void dsc(){
 100   1         unsigned char tasta, submenu[] = {'A', 'B', 'C', 'D'}, iter = 0, msg = 0x10FF, buf[20], flag = 0;
 101   1         while(1){
 102   2            if(tasta = KEYB_Input())
 103   2               for(iter = 0; iter < 4; iter++){
 104   3                  if(tasta == submenu[iter]){
 105   4                     msg  |= (tasta - 'A');
 106   4                     sprintf(buf, "MSG = %x", msg);
 107   4                     UART0_Putstr(buf);
 108   4                     LCD_PutStr(0,0, buf); 
 109   4                     flag = 1;
 110   4                     break;
 111   4                  }
 112   3               }
 113   2               if(flag == 1)
 114   2                  break;
 115   2            }
 116   1      }
C51 COMPILER V9.59.0.0   TESTCAN                                                           12/05/2024 17:51:04 PAGE 3   

 117          
 118          //************************************************************************************
 119          // Programul principal
 120          //************************************************************************************
 121          void main (void) {
 122   1         unsigned char tasta, counter = 0, iter = 0, buf[16], here = 0;
 123   1         unsigned int  tx = 0;
 124   1      
 125   1         BIG8051_Init();                     // Initializare resurse HW & SW BIG8051
 126   1      
 127   1         CAN_Init_Object(1, CANID_STD, 0x001, 1, MSGOBJ_TX);    // MasgObj = 1, STD, CANID = 0, DLC = 1, TX
 128   1         CAN_Init_Object(2, CANID_STD, 0x000, 1, MSGOBJ_RX);    // MasgObj = 2, STD, CANID = 1, DLC = 1, RX
 129   1         
 130   1         print_menu(MAIN_MENU);
 131   1         while(1){
 132   2            if (tasta = KEYB_Input()){
 133   3               if(tasta == '0' and here != MAIN_MENU){
*** ERROR C141 IN LINE 133 OF TestCAN.c: syntax error near 'and', expected ','
*** ERROR C202 IN LINE 133 OF TestCAN.c: 'and': undefined identifier
*** ERROR C141 IN LINE 133 OF TestCAN.c: syntax error near ')', expected ';'
 134   4                  here = MAIN_MENU;
 135   4                  print_menu(MAIN_MENU);
 136   4               }
 137   3               else if(tasta == '1' and here != DSC_MENU){
*** ERROR C141 IN LINE 137 OF TestCAN.c: syntax error near 'else', expected '__asm'
*** ERROR C141 IN LINE 137 OF TestCAN.c: syntax error near 'and', expected ','
*** ERROR C202 IN LINE 137 OF TestCAN.c: 'and': undefined identifier
*** ERROR C141 IN LINE 137 OF TestCAN.c: syntax error near ')', expected ';'
 138   4                  here = DSC_MENU;
 139   4                  print_menu(DSC_MENU);
 140   4                  dsc();
 141   4               }
 142   3               else if(tasta == '2' and here != WDI_MENU){
*** ERROR C141 IN LINE 142 OF TestCAN.c: syntax error near 'else', expected '__asm'
*** ERROR C141 IN LINE 142 OF TestCAN.c: syntax error near 'and', expected ','
*** ERROR C202 IN LINE 142 OF TestCAN.c: 'and': undefined identifier
*** ERROR C141 IN LINE 142 OF TestCAN.c: syntax error near ')', expected ';'
 143   4                  here = WDI_MENU;
 144   4                  print_menu(WDI_MENU);
 145   4                  wdi();
 146   4               }
 147   3               else if(tasta == '3' and here != RDI_MENU){
 148   4                  here = RDI_MENU;
 149   4                  print_menu(RDI_MENU);
 150   4                  rdi();
 151   4               }
 152   3               else if(tasta == '4' and here != CDI_MENU){
 153   4                  here = CDI_MENU;
 154   4                  print_menu(CDI_MENU);
 155   4                  
 156   4               }
 157   3               else if(tasta == '5' and here != IOCI_MENU){
 158   4                  here = IOCI_MENU;
 159   4                  print_menu(IOCI_MENU);
 160   4                  ioci();
 161   4               }
 162   3      //       
 163   3      //       CAN_MsgTX.Date.Byte[counter] = tasta;        // Pune in buffer octetul de transmis
 164   3      //       counter++;
 165   3      //       if (counter >= 8) {
 166   3      //          tx++;          
 167   3      //          counter = 0;
C51 COMPILER V9.59.0.0   TESTCAN                                                           12/05/2024 17:51:04 PAGE 4   

 168   3      //          CAN_Transmit(1,0,&CAN_MsgTX);          // Transmite datele din buffer cu obiectul 1
 169   3      //          sprintf(buf, "\r\n\r\nTransmis[%d]: %s", tx,CAN_MsgTX.Date.Byte);
 170   3      //          UART0_Putstr(buf);
 171   3      //          sprintf(buf, "Tx[%d]: %s", tx,CAN_MsgTX.Date.Byte);
 172   3      //          LCD_PutStr(0,0, buf);                  
 173   3      
 174   3      //          for(iter = 0; iter > 8; iter++){
 175   3      //             UART0_PutByteHex(CAN_MsgTX.Date.Byte[iter]);          // Afiseaza pe terminal octetul transmis
 176   3      //             LCD_PutByteHex(0, 5 + iter, CAN_MsgTX.Date.Byte[iter]);     // Afiseaza pe LCD octetul transmis
 177   3      //          }
 178   3               }
 179   2            }
 180   1            if(CAN_MsgRX.NewDat){                           // S-au primit date noi?
 181   2               CAN_MsgRX.NewDat = 0;                           // daca da, sterge indicatorul date noi
 182   2               
 183   2               UART0_Putstr("\r\nPrimit: ");
 184   2               UART0_Putch(CAN_MsgRX.Date.Byte[0]);            // afiseaza pe terminal octetul primit
 185   2               LCD_PutStr(1,0, "Primit: ");                    
 186   2               LCD_PutByte(1, LCD_col, CAN_MsgRX.Date.Byte[0]);      // afiseaza pe LCD octetul primit
 187   2            }
 188   1         }
 189          }

C51 COMPILATION COMPLETE.  0 WARNING(S),  11 ERROR(S)
